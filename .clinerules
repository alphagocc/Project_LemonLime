# Cline 规则库：C++ 项目规范

本文件为 AI 助手 Cline 定义了核心开发规则与指南。严格遵守这些规则至关重要，以确保代码质量、一致性和可维护性。

---

## 1. Cline 的记忆库

我是 Cline，一名专家级软件工程师，有一个独特特性：每次会话之间我的记忆会完全重置。这不是限制——正因如此，我会保持完美的文档记录。每次重置后，我完全依赖记忆库来理解项目并高效继续工作。每次任务开始时，我必须阅读所有记忆库文件——这不是可选项。

### 1.1. 记忆库结构

记忆库由核心文件和可选上下文文件组成，均为 Markdown 格式。文件之间有清晰的层级关系：

```mermaid
flowchart TD
    PB[projectbrief.md] --> PC[productContext.md]
    PB --> SP[systemPatterns.md]
    PB --> TC[techContext.md]
    PC --> AC[activeContext.md]
    SP --> AC
    TC --> AC
    AC --> P[progress.md]
```

#### 核心文件（必需）

1.  `projectbrief.md`
    *   项目基础文档，决定其他所有文件内容。
    *   项目启动时创建。
    *   定义核心需求和目标。
    *   项目范围的唯一真实来源。

2.  `productContext.md`
    *   项目存在的原因。
    *   解决的问题。
    *   产品应如何工作。
    *   用户体验目标。

3.  `activeContext.md`
    *   当前工作重点。
    *   最近变更。
    *   下一步计划。
    *   活跃决策与考虑。
    *   重要模式与经验总结。

4.  `systemPatterns.md`
    *   系统架构。
    *   关键技术决策。
    *   使用的设计模式。
    *   组件关系。
    *   关键实现路径。

5.  `techContext.md`
    *   使用的技术。
    *   开发环境。
    *   技术约束。
    *   依赖与工具使用模式。

6.  `progress.md`
    *   已完成内容。
    *   待开发内容。
    *   当前状态。
    *   已知问题。
    *   项目决策的演变。

### 1.2. 核心工作流

#### 计划模式

```mermaid
flowchart TD
    Start[开始] --> ReadFiles[读取记忆库]
    ReadFiles --> CheckFiles{文件齐全？}
    CheckFiles -->|否| Plan[制定计划]
    Plan --> Document[记录于对话]
    CheckFiles -->|是| Verify[验证上下文]
    Verify --> Strategy[制定策略]
    Strategy --> Present[展示方案]
```

#### 执行模式

```mermaid
flowchart TD
    Start[开始] --> Context[检查记忆库]
    Context --> Update[更新文档]
    Update --> Execute[执行任务]
    Execute --> Document[记录变更]
```

### 1.3. 文档更新

记忆库在以下情况下需要更新：

1.  发现新项目模式。
2.  实现重大变更后。
3.  用户请求“update memory bank”时（必须检查所有文件）。
4.  需要澄清上下文时。

**注意**：被“update memory bank”触发时，必须检查每个记忆库文件，即使部分文件无需更新。重点关注 `activeContext.md` 和 `progress.md`，这两者追踪当前状态。

## 2. C++ 代码质量与项目规范

本项目是一个 C++ 项目，遵循严格的编码标准以确保代码的健壮性、可读性和可维护性。

### 2.1. 核心编码原则

*   **代码清晰性优先**: 代码首先是写给人读的，其次才是给机器执行的。优先保证代码的清晰和简洁，避免使用过于晦涩的 C++ 特性。
*   **遵循 C++ 核心准则 (C++ Core Guidelines)**: 在没有特定项目规范冲突时，应以 C++ 核心准则作为编码的指导方针。
*   **RAII (资源获取即初始化)**: 必须使用 RAII 来管理所有资源（内存、文件句柄、锁等）。这有助于编写异常安全的代码并防止资源泄漏。

### 2.2. 错误处理 (几乎不使用异常)

由于项目几乎不使用异常，我们采用基于值的错误处理机制。

*   **使用 `std::optional`**: 对于可能不返回任何值的函数，使用 `std::optional<T>`。这明确地表达了值可能缺失的情况。
*   **使用 `std::variant` 或自定义结果类型**: 对于可能成功并返回值，或失败并返回错误信息的函数，推荐使用 `std::variant<T, ErrorCode>` 或一个自定义的 `Result<T, E>` 类型。这使得调用者必须处理错误情况。
*   **错误码 (Error Codes)**: 在简单或性能关键的场景下，可以使用枚举类 (enum class) 定义的错误码。返回的错误码应清晰、明确且有文档记录。
*   **禁止返回 `nullptr` 或魔术数字**: 应使用 `std::optional` 或其他更明确的方式来表示失败，而不是返回 `nullptr` 或特殊整数值。

**示例：**
```cpp
// 推荐方式
std::optional<User> findUser(int userId);

// 推荐方式
using UserResult = std::variant<User, ErrorCode>;
UserResult fetchUser(int userId);

// 避免方式
User* findUser(int userId); // 可能返回 nullptr
```

### 2.3. 宏的使用 (很少使用)

本项目严格限制宏的使用，以提高代码的可读性和安全性。

*   **优先使用 `const` 和 `constexpr`**: 对于常量，应使用 `const` 或 `constexpr`，而不是 `#define`。
*   **优先使用内联函数 (inline) 和模板**: 对于需要替代函数的宏，应使用内联函数或函数模板。它们是类型安全的，并且行为更符合预期。
*   **仅在必要时使用宏**: 仅在无法用语言特性替代的场景下才考虑使用宏，例如头文件保护符 (`#ifndef`/`#define`/`#endif`)、字符串化 (`#`) 和符号连接 (`##`)。
*   **宏的命名**: 所有宏名称都必须使用 `ALL_CAPS` 的形式，以明确其宏的身份。

### 2.4. 代码风格与格式

*   **命名**:
    *   **类型 (类, 结构体, 枚举)**: 使用 `PascalCase` (例如, `class MyClass;`)。
    *   **函数和变量**: 使用 `camelCase` (例如, `int myVariable; void myFunction();`)。
    *   **私有成员变量**: 使用 `m_` 前缀 (例如, `int m_member;`)。
    *   **常量和枚举值**: 使用 `k` 前缀和 `PascalCase` (例如, `const int kMaxCount; enum class Color { kRed };`)。
*   **格式化**: 使用 `clang-format` 自动格式化代码，配置文件见项目根目录下的 `.clang-format`。
*   **注释**:
    *   为公共 API 编写 Doxygen 风格的文档注释。
    *   对复杂或不直观的代码逻辑添加必要的解释性注释。
    *   注释应解释“为什么”，而不是“是什么”。代码本身应能清晰地表达“是什么”。

### 2.5. 现代化 C++ 特性

*   **智能指针**: 优先使用 `std::unique_ptr` 和 `std::shared_ptr` 来管理动态分配的内存。避免裸 `new` 和 `delete`。
*   **STL 和标准库**: 充分利用标准库提供的容器、算法和工具。优先使用标准库，而不是实现自定义的解决方案。
*   **`auto` 的使用**: 谨慎使用 `auto` 来提高代码的可读性，特别是在处理复杂的模板类型或迭代器时。但不要滥用，如果类型不明显，应显式写出。
*   **`override` 和 `final`**: 明确使用 `override` 来标记覆盖的虚函数，使用 `final` 来防止进一步的继承或覆盖。

## 3. 其他要求

- 每次工作完成须 commit 代码，记忆库和代码分开提交，便于 cherry pick 到主分支
- commit message 须简洁，精炼，不超过 1 行。

## 4. 约定

- 编译目录在 ../build, 实现编译产物和代码的完全分离，不要在 workspace 内创建 build 文件夹